/**
 * Container type to store all information about a single test-case
 */
@groovy.transform.TupleConstructor
class TestCase {
    String name
    long timeInSeconds
    Boolean skipped
    // "An errored test is one that had an unanticipated problem."
    String error
    // "A failure is a test which the code has explicitly failed by using the mechanisms for that purpose."
    String failure
    String sysout
    String syserr
}

/**
 * Creates a TestCase for a test which was aborted due to timeout
 *
 * Required parameters:
 * - name - test case name, must be unique within the test suite
 * - timeInSeconds - test case duration (timeout) in seconds
 *
 * Optional parameters:
 * - sysout - the output of the test process written to standard output
 * - syserr - the output of the test process written to standard error
 *
 * Returns the newly created TestCase object
 */
def createTimeout(args) {
    return new TestCase(args.name, args.timeInSeconds, false, 'Test aborted due to timeout', '', args['sysout'] ?: '', args['syserr'] ?: '')
}

/**
 * Creates a TestCase for a test which passed
 *
 * Required parameters:
 * - name - test case name, must be unique within the test suite
 * - timeInSeconds - test case duration (timeout) in seconds
 *
 * Optional parameters:
 * - sysout - the output of the test process written to standard output
 * - syserr - the output of the test process written to standard error
 *
 * Returns the newly created TestCase object
 */
def createPassed(args) {
    return new TestCase(args.name, args.timeInSeconds, false, '', '', args['sysout'] ?: '', args['syserr'] ?: '')
}

/**
 * Creates a TestCase for a test which was skipped
 *
 * Required parameters:
 * - name - test case name, must be unique within the test suite
 * - timeInSeconds - test case duration (timeout) in seconds
 *
 * Optional parameters:
 * - sysout - the output of the test process written to standard output
 * - syserr - the output of the test process written to standard error
 *
 * Returns the newly created TestCase object
 */
def createSkipped(args) {
    return new TestCase(args.name, args.timeInSeconds, true, '', '', args['sysout'] ?: '', args ['syserr'] ?: '')
}

/**
 * Creates a TestCase for a test which failed
 *
 * Required parameters:
 * - name - test case name, must be unique within the test suite
 * - timeInSeconds - test case duration (timeout) in seconds
 *
 * Optional parameters:
 * - message - the error message, e.g. the reason for the failure
 * - sysout - the output of the test process written to standard output
 * - syserr - the output of the test process written to standard error
 *
 * Returns the newly created TestCase object
 */
def createFailed(args) {
    return new TestCase(args.name, args.timeInSeconds, false, '', args.hasProperty('message') ? args.message : 'Failed', args['sysout'] ?: '', args['syserr'] ?: '')
}

/**
 * Writes the given TestCases into a XML file in the "JUnit" format to be parsed by the Jenkins JUnit plugin.
 *
 * Required parameters:
 * - name - test suite name, must be unique among the Jenkins job
 * - tests - the list of TestCases (or any compatible type) for the actual single test-cases
 *
 * Returns the filename of the "JUnit" XML file created
 */
def generateReport(args) {

    // The layout of the "JUnit" (which is actually not generated by JUnit) XML file is taken from:
    // - https://stackoverflow.com/questions/4922867/what-is-the-junit-xml-format-specification-that-hudson-supports
    // - https://help.catchsoftware.com/display/ET/JUnit+Format

    // out = StringBuilder.newInstance()
    // creates a new (synchronized) StringBuffer, but does not require any additional permissions
    // see: https://stackoverflow.com/questions/1797478/groovy-literal-stringbuilder-stringbuffer
    out = '' << ''

    out.append('<?xml version="1.0" encoding="UTF-8"?>\n')
    // out.append('<testsuites disabled="" errors="" failures="" name="" tests="" time="">\n')
    out.append("<testsuite id=\"${args.name}\" name=\"${args.name}\" tests=\"${args.tests.size()}\">\n")

    for(test in args.tests) {
        out.append("<testcase classname=\"${test.name}\" name=\"${test.name}\" status=\"\" time=\"${test.timeInSeconds}\">\n")
        if(test.skipped)
            out.append('<skipped/>\n')
        if(!test.error.isEmpty())
            out.append("<error message=\"${test.error}\" type=\"\"/>\n")
        if(!test.failure.isEmpty())
            out.append("<failure message=\"${test.failure}\" type=\"\"/>\n")
        if(!test.sysout.isEmpty())
            out.append("<system-out><![CDATA[${test.sysout}]]></system-out>")
        if(!test.syserr.isEmpty())
            out.append("<system-err><![CDATA[${test.syserr}]]></system-err>")
        out.append('</testcase>\n')
    }

    out.append('</testsuite>\n')
    // out.append('</testsuites>\n')

    // Actually write the file
    writeFile file: "${args.name}-junit.xml", text: out.toString()
    out = null
    return "${args.name}-junit.xml"
}

// Required so the functions/variables in here are actually available
return this
